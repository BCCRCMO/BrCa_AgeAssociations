#' Linear models on bootstrapped data
#'
#' Run linear regression models on bootstrapped data
#'
#' This function is a wrapper around `boot_generate`, `boot_stats`, and
#' `boot_counts`.
#'
#' @param data data object with model variables of interest
#' @param x charater string of the explanatory variable in `data`
#' @param y data object from which the variables named in `probes` are found
#' @param group a factor that splits the samples in `data` into different groups
#' @param probes character vector of probe names to model
#' @param genes character vector of gene names represented by the `probes`
#' @param aridxs age-related probes of interest
#' @param age linear model performed on the datasets `x <= age`, `x > age`, and
#'   the full model
#' @param fdr FDR threshold for BH-adjusted p-values statistical significance
#' @param fc fold change threshold for biological significance
#' @param seed random seed for reproducibility
#' @param reps number of bootstrap replicates
#' @param nb an integer stating the bootstrap sample size for each group. If
#'   `NULL` (default), the bootstrap sample size for each group is taken from
#'   the original group-specific sample sizes.
#' @param filename save result object to file
#'
#' @return A list of length `reps`, each of which is a matrix with
#'   `nlevels(group)` rows and two columns, showing for each group, the number
#'   of response variables in `y` that showed a biologically relevant and
#'   statistically significant result.
#' @author Derek Chiu
#' @export
boot_lm <- function(data, x, y, group, probes, genes, aridxs, age = 60,
                    fdr = 0.01, fc = 1.25, seed = 1, reps = 20, nb = NULL,
                    filename = NULL) {
  boot_data <- boot_generate(data = data, group = group, seed = seed,
                             reps = reps, nb = nb)
  stat_data <- boot_stats(boot_data = boot_data, x = x, y = y, probes = probes,
                          genes = genes, aridxs = aridxs, age = age, fdr = fdr,
                          fc = fc)
  results <- boot_counts(stat_data = stat_data, group = group)

  # Save results to file
  if (!is.null(filename))
    readr::write_rds(results, filename)

  return(results)
}

#' Generate bootstrapped data
#'
#' Generate bootstrapped data within each group for a specified number of
#' bootstrap samples and replicates.
#'
#' The `data` is first split by each level in the `group` factor. Then, `reps`
#' replicates of bootstrap samples of size `nb` are generated for each data
#' subset. If no `nb` is specified, the original group-specific sizes are used
#' and no bootstrapping is performed.
#'
#' @inheritParams boot_lm
#' @return A list with length equal to the number of levels in `group`. If `nb`
#'   is not `NULL`, each element itself is a list of `reps` data frames with
#'   `nb` rows. If `nb` is `NULL`, each element is a list of length 1 with a
#'   data frame whose number of rows is equal to its original group-size.
#' @author Derek Chiu
#' @export
#' @examples
#' str(boot_generate(iris, iris$Species, reps = 2, nb = 100), max.level = 2)
#' str(boot_generate(iris, iris$Species), max.level = 2)
boot_generate <- function(data, group, seed = 1, reps = 20, nb = NULL) {
  set.seed(seed)
  dat <- levels(group) %>%
    purrr::set_names() %>%
    purrr::map(~ data[group == ., ])
  if (!is.null(nb)) {
    boot_dat <- dat %>%
      purrr::map(~ purrr::rerun(reps, dplyr::sample_n(., nb, replace = TRUE)))
  } else {
    boot_dat <- dat %>%
      purrr::map(~ purrr::rerun(1, dplyr::sample_frac(.)))
  }
  boot_dat
}

#' Calculate statistics from bootstrapped data
#'
#' Calculate linear model statistics like p-values and slopes from bootstrapped
#' data generated by `boot_generate`.
#'
#' The age-associated linear model for METABRIC expression is run on each of the
#' bootstrapped data objects from `boot_generate`. The slopes, adjusted
#' p-values, and other statistics for the less than or equal to `age`, greater
#' than `age`, and all cases groups are returned.
#'
#' The results are placed in a nested list, since we want them separated by
#' group and replicate. Each of the results is a data frame with 28 variables:
#'
#' * `PROBE`: probe id
#' * `GENE`: gene name
#' * `LE_slope`: estimated slope for less than or equal to `age`
#' * `GT_slope`: estimated slope for greater than `age`
#' * `All_slope`: estimated slope for full data
#' * `LE_pval`: p-value for less than or equal to `age`
#' * `GT_pval`: p-value for less greater than `age`
#' * `All_pval`: p-value for full data
#' * `AgeDependentp`: logical variable for age dependent
#' * `LE_pval_BHadj`: BH-adjusted p-value for less than or equal to `age`
#' * `GT_pval_BHadj`: BH-adjusted p-value for greater than `age`
#' * `All_pval_BHadj`: BH-adjusted p-value for full data
#' * `BHadj_and_AgeDependentp`: logical variable for statistical significance
#' at BH-adjusted p-values and age dependence
#' * `BHadj_signifp`: logical variable for statistical significance at
#' BH-adjusted p-values
#' * `LE_log2FC`: log2 fold change for less than or equal `age`
#' * `GT_log2FC`: log2 fold change for greater than `age`
#' * `All_log2FC`: log2 fold change for full data
#' * `Best_log2FC`: the log2 fold change with the strongest significance
#' * `Best_BHadj_pval`: the BH-adjusted p-value with the strongest significance
#' * `Abs_Best_log2FC`: absolute value of `Best_log2FC`
#' * `Abs_FoldChange`: `2 ^ Abs_Best_log2FC`
#' * `FoldChange_Direction`: "UP" if `Best_log2FC > 0`, "DOWN" otherwise
#' * `arGeneSetidxp`: logical variable for probes found in `aridxs`
#' * `arGeneSet_LE_BHadj_pval`: BH-adjusted p-value for less than or equal to
#' `age` if probe is in `aridxs`, `NA` otherwise
#' * `arGeneSet_GT_BHadj_pval`: BH-adjusted p-value for greater than `age` if
#' probe is in `aridxs`, `NA` otherwise
#' * `arGeneSet_All_BHadj_pval`: BH-adjusted p-value for full data if probe is
#' in `aridxs`, `NA` otherwise
#' * `arGeneSet_BHadj_and_AgeDependentp`: logical variable for statistical
#' significance at BH-adjusted p-values and age dependence if found in `aridxs`,
#' `NA` otherwise
#' * `arGeneSet_PBHadj`: the smallest of `arGeneSet_LE_BHadj_pval`,
#' `arGeneSet_GT_BHadj_pval`, and `arGeneSet_All_BHadj_pval`
#'
#' @param boot_data bootstrapped data from `boot_generate`
#' @inheritParams boot_lm
#' @return A nested list of length equal to the number of replicates specified
#'   in the generation of `boot_data`. Each element is itself a list of data
#'   frames, one for each of the groups in `boot_data`. In essence, the data
#'   structure is a transpose of that found in `boot_data`. The number of rows
#'   in each of the statistical result data frames is equal to the number of
#'   `probes` (and `genes`).
#' @author Derek Chiu
#' @export
boot_stats <- function(boot_data, x, y, probes, genes, aridxs, age = 60,
                       fdr = 0.01, fc = 1.25) {
  # Constants for biological significance
  biosigslopeLE <- biosigslopeGT <- log2(fc) / 35
  biosigslopeAll <- log2(fc) / 70
  multcompPval <- fdr / (2 * length(probes))

  # Get lm statistics in a matrix for bootstrapped data
  stat_mat <- boot_data %>%
    purrr::transpose() %>%
    purrr::modify_depth(2, function(d) {
      purrr::map(probes, function(p) {
        df <- cbind(d, probeset = y[match(d[["MBid"]], rownames(y)),
                                    match(p, colnames(y))])
        list(df[[x]] <= age, df[[x]] > age, NULL) %>%
          purrr::map(~ lm(df[["probeset"]] ~ df[[x]], na.action = na.exclude,
                          age = .x)) %>%
          purrr::map(broom::tidy) %>%
          purrr::map(`[`, -1, c("estimate", "p.value")) %>%
          dplyr::bind_rows() %>%
          unlist()
      }) %>%
        purrr::invoke(rbind, .) %>%
        as.data.frame() %>%
        magrittr::set_colnames(c("LE_slope", "GT_slope", "All_slope",
                                 "LE_pval", "GT_pval", "All_pval")) %>%
        dplyr::mutate(
          PROBE = probes,
          GENE = genes,
          !!"AgeDependentp" :=
            (abs(.data$LE_slope) > biosigslopeLE & .data$LE_pval < multcompPval) |
            (abs(.data$GT_slope) > biosigslopeGT & .data$GT_pval < multcompPval) |
            (abs(.data$All_slope) > biosigslopeAll & .data$All_pval < multcompPval),
          !!"LE_pval_BHadj" := p.adjust(.data$LE_pval, method = "BH"),
          !!"GT_pval_BHadj" := p.adjust(.data$GT_pval, method = "BH"),
          !!"All_pval_BHadj" := p.adjust(.data$All_pval, method = "BH"),
          !!"BHadj_and_AgeDependentp" :=
            (abs(.data$LE_slope) > biosigslopeLE & .data$LE_pval_BHadj < fdr) |
            (abs(.data$GT_slope) > biosigslopeGT & .data$GT_pval_BHadj < fdr) |
            (abs(.data$All_slope) > biosigslopeAll & .data$All_pval_BHadj < fdr),
          !!"BHadj_signifp" := .data$LE_pval_BHadj < fdr |
            .data$GT_pval_BHadj < fdr |
            .data$All_pval_BHadj < fdr,
          !!"LE_log2FC" := .data$LE_slope * 35,
          !!"GT_log2FC" := .data$GT_slope * 35,
          !!"All_log2FC" := .data$All_slope * 70,
          !!"LE_Bestp" := abs(.data$LE_slope) > biosigslopeLE & .data$LE_pval_BHadj < fdr,
          !!"GT_Bestp" := abs(.data$GT_slope) > biosigslopeGT &
            .data$GT_pval_BHadj < fdr & abs(.data$GT_slope) > abs(.data$LE_slope),
          !!"All_Bestp" := abs(.data$All_slope) > biosigslopeAll &
            .data$All_pval_BHadj < fdr &
            (abs(.data$All_log2FC) > abs(.data$LE_log2FC) |
               abs(.data$All_log2FC) > abs(.data$GT_log2FC)),
          !!"Best_log2FC" := dplyr::case_when(
            .data$All_Bestp ~ .data$All_log2FC,
            .data$GT_Bestp ~ .data$GT_log2FC,
            .data$LE_Bestp ~ .data$LE_log2FC,
            TRUE ~ .data$All_log2FC
          ),
          !!"Best_BHadj_pval" := dplyr::case_when(
            .data$All_Bestp ~ .data$All_pval_BHadj,
            .data$GT_Bestp ~ .data$GT_pval_BHadj,
            .data$LE_Bestp ~ .data$LE_pval_BHadj,
            TRUE ~ .data$All_pval_BHadj
          ),
          !!"Abs_Best_log2FC" := abs(.data$Best_log2FC),
          !!"Abs_FoldChange" := 2 ^ .data$Abs_Best_log2FC,
          !!"FoldChange_Direction" := ifelse(.data$Best_log2FC > 0, "Up", "Down"),
          !!"arGeneSetidxp" := .data$PROBE %in% .data$PROBE[aridxs],
          !!"arGeneSet_LE_slope" := abs(value_if(.data$LE_slope, .data$arGeneSetidx)),
          !!"arGeneSet_GT_slope" := abs(value_if(.data$GT_slope, .data$arGeneSetidxp)),
          !!"arGeneSet_All_slope" := abs(value_if(.data$All_slope, .data$arGeneSetidxp)),
          !!"arGeneSet_LE_BHadj_pval" := p.adjust(value_if(.data$LE_pval, .data$arGeneSetidxp), method = "BH"),
          !!"arGeneSet_GT_BHadj_pval" := p.adjust(value_if(.data$GT_pval, .data$arGeneSetidxp), method = "BH"),
          !!"arGeneSet_All_BHadj_pval" := p.adjust(value_if(.data$All_pval, .data$arGeneSetidxp), method = "BH"),
          !!"arGeneSet_BHadj_and_AgeDependentp" :=
            ifelse(.data$arGeneSetidxp,
                   .data$arGeneSet_LE_slope > biosigslopeLE & .data$arGeneSet_LE_BHadj_pval < fdr |
                     .data$arGeneSet_GT_slope > biosigslopeGT & .data$arGeneSet_GT_BHadj_pval < fdr |
                     .data$arGeneSet_All_slope > biosigslopeAll & .data$arGeneSet_All_BHadj_pval > fdr,
                   NA),
          !!"arGeneSet_PBHadj" := pmin(
            .data$arGeneSet_LE_BHadj_pval, .data$arGeneSet_GT_BHadj_pval, .data$arGeneSet_All_BHadj_pval
          )
        ) %>%
        dplyr::select(-dplyr::one_of(
          c("LE_Bestp", "GT_Bestp", "All_Bestp",
            "arGeneSet_LE_slope", "arGeneSet_GT_slope", "arGeneSet_All_slope")
        )) %>%
        dplyr::select(.data$PROBE, .data$GENE, dplyr::everything())
    })
  stat_mat
}

#' Identify the top probes/genes from the linear models and the counts of
#' probes/genes that were found to have a trend or not with age
#' @noRd
boot_counts <- function(stat_data, group) {
  top_probes <- stat_data %>%
    purrr::modify_depth(2, ~ with(., PROBE[BHadj_and_AgeDependentp]))
  top_genes <- stat_data %>%
    purrr::modify_depth(2, ~ with(., GENE[BHadj_and_AgeDependentp]))
  counts_probes <- stat_data %>%
    purrr::modify_depth(2, ~ dplyr::summarize(
      .,
      trend = sum(BHadj_and_AgeDependentp),
      no_trend = sum(!BHadj_and_AgeDependentp)
    )) %>%
    purrr::map(~ as.matrix(purrr::invoke(rbind, .x)))

  ngenes <- stat_data %>%
    purrr::modify_depth(2, nrow) %>%
    unlist() %>%
    unique()
  counts_genes <- top_genes %>%
    purrr::map(~ dplyr::tibble(
      trend = purrr::map_int(.x, ~ dplyr::n_distinct(na.omit(.x))),
      no_trend = ngenes - trend) %>%
        as.matrix() %>%
        magrittr::set_rownames(levels(group)))
  dplyr::lst(top_probes, top_genes, counts_probes, counts_genes)
}

#' Top probes from bootstrap analysis
#'
#' List of top probes chosen most frequently out of all bootstrap replicates.
#'
#' To quantify what is meant by most frequent, the `freqs` vector serves as a
#' threshold. For example, if `freqs = c(10, 15, 19, 20)`, then we are
#' interested in the probes that were chosen in 10, 15, 19, 20 (out of 20)
#' replicates.
#'
#' @param stat_data statistics data from `boot_stats`
#' @param freqs thresholds of frequencies for top probes
#' @inheritParams boot_lm
#' @export
boot_top <- function(stat_data, group, freqs) {
  boot_counts(stat_data, group) %>%
    magrittr::use_series("top_probes") %>%
    purrr::transpose() %>%
    purrr::map(~ table(unlist(.x))) %>%
    purrr::map(~ purrr::map(freqs, function(c) names(which(.x >= c))))
}

#' Summarize bootstrap analysis
#'
#' The trend and no_trend counts across replicates using different averaging
#' statistics
#'
#' @param data data object from `boot_lm`
#' @param fun summarize bootstrap statistics using the "mean" or "median"
#' @export
boot_summarize <- function(data, fun = c("mean", "median")) {
  stat <- eval(parse(text = match.arg(fun)))
  group_summ <- data %>%
    boot_munge() %>%
    dplyr::group_by(.data$group) %>%
    dplyr::summarize_at(dplyr::vars(.data$trend:.data$no_trend), stat) %>%
    dplyr::rename_if(is.numeric, dplyr::funs(paste(fun, ., sep = "_"))) %>%
    dplyr::mutate(!!"group" := as.character(.data$group)) %>%
    as.data.frame()
  overall_summ <- cbind(
    dplyr::tibble(group = fun),
    dplyr::summarize_if(group_summ, is.numeric, stat)
  )
  dplyr::bind_rows(group_summ, overall_summ)
}

#' Boxplot of proportion of significant results per group
#'
#' Boxplot for each group, showing distribution of bootstrap proportions
#'
#' @inheritParams boot_summarize
#' @param title plot title
#' @export
boot_boxplot <- function(data, title = NULL) {
  p <- data %>%
    boot_munge() %>%
    ggplot(aes_(x = ~group, y = ~proportion)) +
    geom_boxplot() +
    geom_jitter(position = position_jitter(width = 0.1, height = 0),
                color = "red") +
    labs(x = "intClust group", y = "Proportion age-associated")
  if (!is.null(title)) p + ggtitle(title) else p
}

#' Takes input from data result in boot_lm, calculates proportion of trend
#' @noRd
boot_munge <- function(data) {
  bp <- data %>%
    purrr::imap(~ magrittr::set_colnames(.x, paste(colnames(.x), .y))) %>%
    purrr::map_dfc(as.data.frame) %>%
    dplyr::mutate(group = factor(seq_len(nrow(.)))) %>%
    tidyr::gather("pattern", "value", -dplyr::contains("group")) %>%
    tidyr::separate(
      col = "pattern",
      into = c("pattern", "rep"),
      sep = " ",
      convert = TRUE
    ) %>%
    tidyr::spread("pattern", "value") %>%
    dplyr::mutate(
      !!"proportion" := .data$trend / (.data$no_trend + .data$trend)
    )
  bp
}
